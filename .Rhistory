return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
View(df)
View(df)
current_year <- as.numeric(format(Sys.Date(), "%Y"))
df$age <- current_year - df$Year
View(df)
unique(df$UsedOrNew)
summary(df)
df <- df %>%
mutate(Kilometres_num = as.numeric(gsub("[^0-9]", "", Kilometres)))
df <- df %>%
filter(!is.na(Kilometres_num), !is.na(Price))
show.correlation.plot <- function(df, target, col){
p <- ggplot(df, aes(x = .data[[col]], y = .data[[target]])) +
geom_point(alpha = 0.5, color = "steelblue") +
geom_smooth(method = "lm", color = "red") +  # Linear trend line
labs(title = paste0(target, " vs. ", col), x = col, y = target) +
theme_minimal()
return(p)
}
plots <- map(PREDICTORS, ~show.correlation.plot(df = df, target = TARGET, col = .x))
walk(plots, print)
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
# Exclude 'Price' column
# selected_data <- df_clean %>% select(-Price)
#
# # Compute correlation matrix
# cor_matrix <- cor(selected_data, use = "complete.obs")  # Handles NAs by pairwise deletion
# Plot correlations
cor_data <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
cor_matrix <- cor(cor_data, use = "complete.obs")
show.corrplot(cor_matrix)
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
scale_x_log10(labels = scales::comma) +  # Log scale for skewed data
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
write.csv(df, file = "../../data/preprocessed/cars_v1.csv", row.names = FALSE)  # Avoid row numbers
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
View(df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand', 'Year', 'Model',
'Car_Suv', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres_num')
TARGET <- 'Price'
df <- df[, c(PREDICTORS, TARGET)]
PREDICTORS <- c('Brand_encoded', 'age', 'Model_encoded',
'Car_Suv_encoded', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres')
TARGET <- 'Price'
df <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand', 'Year', 'Model',
'Car_Suv', 'UsedOrNew',
'Transmission', 'Kilometres_num')
TARGET <- 'Price'
df <- df[, c(PREDICTORS, TARGET)]
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand', 'Year', 'Model',
'Car_Suv', 'UsedOrNew',
'Transmission', 'Kilometres')
TARGET <- 'Price'
df <- df[, c(PREDICTORS, TARGET)]
df
missing_counts <- colSums(is.na(df))
print(missing_counts)
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)),
Missing_Percent = round(colMeans(is.na(df)) * 100, 2)
)
print(missing_summary)
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
)
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df))
)
print(missing_summary)
which(is.na(df$Brand))
which(is.na(df$Price))
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
which(is.na(df$Brand))
df <- df[!is.na(df$Brand), ]
which(is.na(df$Brand))
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
print(missing_summary)
library(tidyverse)
library(dplyr)
df <- df %>%
mutate(Price = ifelse(is.na(Price), median(Price, na.rm = TRUE), Price))
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
print(missing_summary)
numeric_cols <- df[, sapply(df, is.numeric)]
# Create boxplots for all numeric columns
boxplot(numeric_cols, main = "Boxplot of Numeric Columns",
las = 2, col = "lightblue", outline = TRUE)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
paste("Loading dataset from '", getwd(), "'")
df1 <- read_csv("../../data/preprocessed/cars_v1.csv", show_col_types = FALSE)
summary(df)
View(df1)
View(df1)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
summary(df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand_encoded', 'age', 'Model_encoded',
'Car_Suv_encoded', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres_num')
TARGET <- 'Price'
df
colMeans(is.na(df))
df <- df %>%
filter(complete.cases(.))
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
current_year <- as.numeric(format(Sys.Date(), "%Y"))
df$age <- current_year - df$Year
View(df)
unique(df$UsedOrNew)
summary(df)
df <- df %>%
mutate(Kilometres_num = as.numeric(gsub("[^0-9]", "", Kilometres)))
df <- df %>%
filter(!is.na(Kilometres_num), !is.na(Price))
show.correlation.plot <- function(df, target, col){
p <- ggplot(df, aes(x = .data[[col]], y = .data[[target]])) +
geom_point(alpha = 0.5, color = "steelblue") +
geom_smooth(method = "lm", color = "red") +  # Linear trend line
labs(title = paste0(target, " vs. ", col), x = col, y = target) +
theme_minimal()
return(p)
}
plots <- map(PREDICTORS, ~show.correlation.plot(df = df, target = TARGET, col = .x))
walk(plots, print)
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
# Exclude 'Price' column
# selected_data <- df_clean %>% select(-Price)
#
# # Compute correlation matrix
# cor_matrix <- cor(selected_data, use = "complete.obs")  # Handles NAs by pairwise deletion
# Plot correlations
cor_data <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
cor_matrix <- cor(cor_data, use = "complete.obs")
show.corrplot(cor_matrix)
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
scale_x_log10(labels = scales::comma) +  # Log scale for skewed data
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
write.csv(df, file = "../../data/preprocessed/cars_v1.csv", row.names = FALSE)  # Avoid row numbers
paste("Loading dataset from '", getwd(), "'")
df1 <- read_csv("../../data/preprocessed/cars_v1.csv", show_col_types = FALSE)
summary(df)
View(df1)
paste("Loading dataset from '", getwd(), "'")
df1 <- read_csv("../../data/preprocessed/cars_v1.csv", show_col_types = FALSE)
summary(df1)
View(df1)
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand', 'Year', 'Model',
'Car_Suv', 'UsedOrNew',
'Transmission', 'Kilometres')
TARGET <- 'Price'
df <- df[, c(PREDICTORS, TARGET)]
df
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
numeric_cols <- df[, sapply(df, is.numeric)]
# Create boxplots for all numeric columns
boxplot(numeric_cols, main = "Boxplot of Numeric Columns",
las = 2, col = "lightblue", outline = TRUE)
library(tidyverse)
library(dplyr)
library(ggplot2)
df_long <- df %>%
select(where(is.numeric)) %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value")
# Create the boxplot
ggplot(df_long, aes(x = Variable, y = Value)) +
geom_boxplot(outlier.colour = "red", fill = "skyblue") +
theme_minimal() +
labs(title = "Boxplots of Numeric Columns") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(ggplot2)
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand', 'Year', 'Model',
'Car_Suv', 'UsedOrNew',
'Transmission', 'Kilometres')
TARGET <- 'Price'
df <- df[, c(PREDICTORS, TARGET)]
df
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
print(missing_summary)
which(is.na(df$Brand))
df <- df[!is.na(df$Brand), ]
df <- df %>%
mutate(Price = ifelse(is.na(Price), median(Price, na.rm = TRUE), Price))
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
print(missing_summary)
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
numeric_cols <- df[, sapply(df, is.numeric)]
# Create boxplots for all numeric columns
boxplot(numeric_cols, main = "Boxplot of Numeric Columns",
las = 2, col = "lightblue", outline = TRUE)
df_long <- df %>%
select(where(is.numeric)) %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value")
# Create the boxplot
ggplot(df_long, aes(x = Variable, y = Value)) +
geom_boxplot(outlier.colour = "red", fill = "skyblue") +
theme_minimal() +
labs(title = "Boxplots of Numeric Columns") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
View(df_long)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand', 'Year', 'Model',
'Car_Suv', 'UsedOrNew',
'Transmission', 'Kilometres')
TARGET <- 'Price'
df <- df[, c(PREDICTORS, TARGET)]
df
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
print(missing_summary)
which(is.na(df$Brand))
df <- df[!is.na(df$Brand), ]
df <- df %>%
mutate(Price = ifelse(is.na(Price), median(Price, na.rm = TRUE), Price))
missing_summary <- data.frame(
Column = names(df),
Missing_Count = colSums(is.na(df)))
print(missing_summary)
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
numeric_cols <- df[, sapply(df, is.numeric)]
# Create boxplots for all numeric columns
boxplot(numeric_cols, main = "Boxplot of Numeric Columns",
las = 2, col = "lightblue", outline = TRUE)
df_long <- df %>%
select(where(is.numeric)) %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value")
# Create the boxplot
ggplot(df_long, aes(x = Variable, y = Value)) +
geom_boxplot(outlier.colour = "red", fill = "skyblue") +
theme_minimal() +
labs(title = "Boxplots of Numeric Columns") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
summary(df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
PREDICTORS <- c('Brand_encoded', 'age', 'Model_encoded',
'Car_Suv_encoded', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres_num')
TARGET <- 'Price'
df
colMeans(is.na(df))
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
View(df)
View(df)
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df
current_year <- as.numeric(format(Sys.Date(), "%Y"))
df$age <- current_year - df$Year
View(df)
unique(df$UsedOrNew)
summary(df)
current_year <- as.numeric(format(Sys.Date(), "%Y"))
df$age <- current_year - df$Year
View(df)
unique(df$UsedOrNew)
summary(df)
View(df)
write.csv(df, file = "../../data/preprocessed/cars_v2.csv", row.names = FALSE)  # Avoid row numbers
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
paste("Loading dataset from '", getwd(), "'")
df1 <- read_csv("../../data/preprocessed/cars_v2.csv", show_col_types = FALSE)
summary(df1)
View(df1)
