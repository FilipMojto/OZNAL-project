#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../data/raw/data.csv", show_col_types = FALSE)
View(df)
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
# target is now treated as factor (required in boxplots for proper binning)
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
summary(selected_data)
nrows <- nrow(df)
get_nan_percentage <- function(filter = FALSE) {
nans <- df %>%
summarise(across(everything(), ~round(sum(is.na(.)) / nrow(df) * 100, 2))) %>%
rename_with(~paste0(., "_%"))
if (filter) {
# Keep only columns where NA percentage > 0
nans <- nans %>%
select(where(~ . > 0))
}
return(nans)
}
nan_percentage <- get_nan_percentage()
nan_percentage
nan_cols <- nan_percentage %>%
select(where(~ . > 0))
cat("No. of cols with missing values:", ncol(nan_cols))
show.boxplot <- function(data, cols, target){
plots <- map(cols, ~ggplot(
data,
aes(x = .data[[target]], y = .data[[.x]])) +
geom_boxplot(aes(group = .data[[target]])) +
theme_minimal()
)
walk(plots, print)
}
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
show.boxplot(data = selected_data, cols = PREDICTOR_NAMES, target = TARGET)
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
# we need to truncate the predictor names so that the results are displayed
# better
cor_matrix <- cor(selected_data[,PREDICTOR_NAMES])
truncate_labels <- function(labels, max_length = 20) {
sapply(labels, function(lab) {
if (nchar(lab) > max_length) {
paste0(substr(lab, 1, max_length), "…")  # ellipsis
} else {
lab
}
})
}
# applying truncation
colnames(cor_matrix) <- truncate_labels(colnames(cor_matrix))
rownames(cor_matrix) <- truncate_labels(rownames(cor_matrix))
show.corrplot(cor_matrix)
show.histogram <- function(df, cols, target) {
plot_list <- map(cols, ~ {
ggplot(data = df, aes(x = .data[[.x]], fill = as.factor(.data[[target]]))) +
geom_histogram(position = "identity", alpha = 0.5, bins = 30, color = "black") +
scale_fill_manual(values = c('blue', 'red')) +  # Customize fill colors
labs(title = paste("Histogram for", .x), x = .x, y = "Count") +
theme_minimal() +
theme(legend.title = element_blank())
})
walk(plot_list, print)
}
# Usage example:
show.histogram(selected_data, PREDICTOR_NAMES, TARGET)
show.densityplot <- function(df, cols, target) {
plot_list <- map(cols, ~ {
ggplot(data = df, aes(x = .data[[.x]], fill = as.factor(.data[[target]]))) +
geom_density(alpha = 0.5) +  # Adjust transparency for overlapping
scale_fill_manual(values = c('blue', 'red')) +  # Customize fill colors
labs(title = paste("Density Plot for", .x), x = .x, y = "Density") +
theme_minimal() +
theme(legend.title = element_blank())
})
walk(plot_list, print)
}
# Usage example:
show.densityplot(selected_data, PREDICTOR_NAMES, TARGET)
show.scatterplot <- function(df, cols){
plot_list <- map(cols, ~ ggplot(
data = df,
mapping = aes(x = .data[[.x]])
) + geom_density(fill = 'green') +
theme_minimal())
walk(plot_list, print)
}
show.scatterplot(selected_data, PREDICTOR_NAMES)
show.curve.scatterplot <- function(df, cols, target){
# Coerce target safely: factor → character → numeric
df <- df %>%
mutate(y_numeric = as.numeric(as.character(.data[[target]])))
plot_list <- map(cols, ~ ggplot(df, aes(x = .data[[.x]], y = y_numeric)) +
geom_jitter(width = 0.1, alpha = 0.5) +
geom_smooth(method = "loess", se = FALSE) +
labs(title = paste("Predictor:", .x), y = "Target (0 = No, 1 = Yes)") +
theme_minimal()
)
walk(plot_list, print)
}
show.curve.scatterplot(df = selected_data, cols = PREDICTOR_NAMES, target = TARGET)
# show.scatterplot_with_sigmoid <- function(df, cols, target) {
#
#   plot_list <- map(cols, ~ ggplot(
#     data = df,
#     mapping = aes(x = .data[[.x]], y = .data[[target]])
#   ) +
#     geom_point(color = 'blue', alpha = 0.5) +  # Scatter plot points
#     geom_smooth(method = "glm",
#                 method.args = list(family = "binomial"),  # Logistic regression (sigmoid)
#                 se = FALSE, color = 'red') +  # Logistic regression line
#     theme_minimal())
#
#   walk(plot_list, print)
# }
#
# show.scatterplot_with_sigmoid(selected_data, PREDICTOR_NAMES, TARGET)
library(MASS)
library(ggplot2)
library(dplyr)
library(purrr)
# Your target variable
TARGET <- "Bankrupt?"
# Make sure the target is a factor
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Construct a valid formula with backticks
model_formula <- as.formula(paste0("`", TARGET, "` ~ ."))
# Fit QDA
qda_model <- qda(model_formula, data = selected_data)
# Store predictions
selected_data$qda_pred <- predict(qda_model)$posterior[,2]
# Define residual plotting function
plot_residuals <- function(model_type) {
walk(PREDICTOR_NAMES, ~{
residuals <- selected_data[[paste0(model_type, "_pred")]] -
as.numeric(as.character(selected_data[[TARGET]]))
p <- ggplot(selected_data, aes(x = .data[[.x]], y = residuals)) +
geom_point(alpha = 0.5) +
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
geom_smooth(method = "loess", color = "blue", se = FALSE) +
labs(title = paste("Residuals vs", .x, "(", model_type, ")"),
x = .x,
y = "Residuals (Predicted - Actual)") +
theme_minimal()
print(p)
})
}
# Plot residuals for LDA and QDA
plot_residuals("qda")
library(knitr)
kable_correlation <- kable(cor_matrix, format = "markdown")
writeLines(kable_correlation, "../output/tables/independence_matrix.md")
{r}
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
# Set seed for reproducibility
set.seed(123)
# Convert target to factor for classification
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Create train/test split (optional but recommended)
train_index <- createDataPartition(selected_data[[TARGET]], p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Train Random Forest model
rf_model <- train(
as.formula(paste(TARGET, "~ .")),
data = train_data,
method = "rf",
trControl = trainControl(method = "cv", number = 5),  # 5-fold cross-validation
tuneLength = 5  # tries different mtry values
)
# Set seed for reproducibility
set.seed(123)
# Convert target to factor for classification
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Create train/test split (optional but recommended)
train_index <- createDataPartition(selected_data[[TARGET]], p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Train Random Forest model
rf_model <- train(
as.formula(paste0("`", TARGET, "` ~ ."))
data = train_data,
# Set seed for reproducibility
set.seed(123)
# Convert target to factor for classification
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Create train/test split (optional but recommended)
train_index <- createDataPartition(selected_data[[TARGET]], p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Train Random Forest model
rf_model <- train(
as.formula(paste0("`", TARGET, "` ~ .")),
data = train_data,
method = "rf",
trControl = trainControl(method = "cv", number = 5),  # 5-fold cross-validation
tuneLength = 5  # tries different mtry values
)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../data/raw/data.csv", show_col_types = FALSE)
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
# Set seed for reproducibility
set.seed(123)
# Convert target to factor for classification
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Create train/test split (optional but recommended)
train_index <- createDataPartition(selected_data[[TARGET]], p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Train Random Forest model
rf_model <- train(
as.formula(paste0("`", TARGET, "` ~ .")),
data = train_data,
method = "rf",
trControl = trainControl(method = "cv", number = 5),  # 5-fold cross-validation
tuneLength = 5  # tries different mtry values
)
# Output the model summary
print(rf_model)
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 5, 6, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 5, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../data/raw/data.csv", show_col_types = FALSE)
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 5, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
# we need to truncate the predictor names so that the results are displayed
# better
cor_matrix <- cor(selected_data[,PREDICTOR_NAMES])
truncate_labels <- function(labels, max_length = 20) {
sapply(labels, function(lab) {
if (nchar(lab) > max_length) {
paste0(substr(lab, 1, max_length), "…")  # ellipsis
} else {
lab
}
})
}
# applying truncation
colnames(cor_matrix) <- truncate_labels(colnames(cor_matrix))
rownames(cor_matrix) <- truncate_labels(rownames(cor_matrix))
show.corrplot(cor_matrix)
# Set seed for reproducibility
set.seed(123)
# Convert target to factor for classification
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Create train/test split (optional but recommended)
train_index <- createDataPartition(selected_data[[TARGET]], p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Train Random Forest model
rf_model <- train(
as.formula(paste0("`", TARGET, "` ~ .")),
data = train_data,
method = "rf",
trControl = trainControl(method = "cv", number = 5),  # 5-fold cross-validation
tuneLength = 5  # tries different mtry values
)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../data/raw/data.csv", show_col_types = FALSE)
TARGET = 'Bankrupt?'
# indices of predictors
PREDICTORS = c(2, 5, 7, 8, 9, 10, 24, 25, 26, 27, 28, 29, 30, 31, 32)
PREDICTOR_NAMES <- names(df)[PREDICTORS]
cat("Predictors: \n")
walk(PREDICTOR_NAMES, print)
selected_data <- df %>%
select(all_of(PREDICTORS), all_of(TARGET))
selected_data
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
# we need to truncate the predictor names so that the results are displayed
# better
cor_matrix <- cor(selected_data[,PREDICTOR_NAMES])
truncate_labels <- function(labels, max_length = 20) {
sapply(labels, function(lab) {
if (nchar(lab) > max_length) {
paste0(substr(lab, 1, max_length), "…")  # ellipsis
} else {
lab
}
})
}
# applying truncation
colnames(cor_matrix) <- truncate_labels(colnames(cor_matrix))
rownames(cor_matrix) <- truncate_labels(rownames(cor_matrix))
show.corrplot(cor_matrix)
# Set seed for reproducibility
set.seed(123)
# Convert target to factor for classification
selected_data[[TARGET]] <- as.factor(selected_data[[TARGET]])
# Create train/test split (optional but recommended)
train_index <- createDataPartition(selected_data[[TARGET]], p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Train Random Forest model
rf_model <- train(
as.formula(paste0("`", TARGET, "` ~ .")),
data = train_data,
method = "rf",
trControl = trainControl(method = "cv", number = 5),  # 5-fold cross-validation
tuneLength = 5  # tries different mtry values
)
# Output the model summary
print(rf_model)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
# we need to truncate the predictor names so that the results are displayed
# better
cor_matrix <- cor(selected_data[,PREDICTOR_NAMES])
truncate_labels <- function(labels, max_length = 20) {
sapply(labels, function(lab) {
if (nchar(lab) > max_length) {
paste0(substr(lab, 1, max_length), "…")  # ellipsis
} else {
lab
}
})
}
# applying truncation
colnames(cor_matrix) <- truncate_labels(colnames(cor_matrix))
rownames(cor_matrix) <- truncate_labels(rownames(cor_matrix))
show.corrplot(cor_matrix)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
