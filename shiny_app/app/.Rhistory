conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
summary(df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
df$Brand_Model <- paste(df$Brand, df$Model)
PREDICTORS <- c('Brand_encoded', 'age', 'Model_encoded',
'Car_Suv_encoded', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres_num',
'Cylinders', 'Engine_L', 'DriveType_encoded',
'FuelType_encoded', 'FuelConsumption_num',
'ColourExtInt_encoded', 'Location_encoded',
'BodyType_encoded', 'Doors_num', 'Seats_num', 'Brand_Model_encoded')
TARGET <- 'Price'
df
# For a single column (e.g., 'Seats')
colMeans(is.na(df))
df <- df %>%
filter(complete.cases(.))
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission', 'DriveType', 'FuelType', 'ColourExtInt', 'Location', 'BodyType', 'Brand_Model')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
df %>% select(Brand, Brand_encoded.x)
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission', 'DriveType', 'FuelType', 'ColourExtInt', 'Location', 'BodyType', 'Brand_Model')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
library(scales)  # for comma()
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
summary(df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
df$Brand_Model <- paste(df$Brand, df$Model)
PREDICTORS <- c('Brand_encoded', 'age', 'Model_encoded',
'Car_Suv_encoded', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres_num',
'Cylinders', 'Engine_L', 'DriveType_encoded',
'FuelType_encoded', 'FuelConsumption_num',
'ColourExtInt_encoded', 'Location_encoded',
'BodyType_encoded', 'Doors_num', 'Seats_num', 'Brand_Model_encoded')
TARGET <- 'Price'
df
# For a single column (e.g., 'Seats')
colMeans(is.na(df))
df <- df %>%
filter(complete.cases(.))
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission', 'DriveType', 'FuelType', 'ColourExtInt', 'Location', 'BodyType', 'Brand_Model')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
current_year <- as.numeric(format(Sys.Date(), "%Y"))
df$age <- current_year - df$Year
# extract actually replaces the original column with new ones based on regex match
df <- df %>%
extract(
Engine,                 # The source column containing engine info
into = c("Cylinders", "Engine_L"),  # New columns to create
regex = "(\\d+) cyl, (\\d+\\.?\\d*) L",  # Pattern to match
convert = TRUE          # Automatically convert to appropriate data types
)
df
df <- df %>%
mutate(
FuelConsumption_num = as.numeric(str_extract(FuelConsumption, "\\d+\\.?\\d*"))
)
df
df$Doors_num <- as.numeric(gsub("[^0-9]", "", df$Doors))
df$Seats_num <- as.numeric(gsub("[^0-9]", "", df$Seats))
df
unique(df$UsedOrNew)
summary(df)
df <- df %>%
mutate(Kilometres_num = as.numeric(gsub("[^0-9]", "", Kilometres)))
df <- df %>%
filter(!is.na(Kilometres_num), !is.na(Price))
show.correlation.plot <- function(df, target, col){
p <- ggplot(df, aes(x = .data[[col]], y = .data[[target]])) +
geom_point(alpha = 0.5, color = "steelblue") +
geom_smooth(method = "lm", color = "red") +  # Linear trend line
labs(title = paste0(target, " vs. ", col), x = col, y = target) +
theme_minimal()
return(p)
}
plots <- map(PREDICTORS, ~show.correlation.plot(df = df, target = TARGET, col = .x))
walk(plots, print)
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
cor_data <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
cor_matrix <- cor(cor_data, use = "complete.obs")
show.corrplot(cor_matrix)
show.boxplot <- function(data, cols, target, bins = 5) {
data <- data %>%
mutate(target_binned = cut(.data[[target]], breaks = bins, include.lowest = TRUE))
plots <- map(cols, ~ggplot(
data,
aes(x = target_binned, y = .data[[.x]])) +
geom_boxplot(aes(group = target_binned)) +
labs(x = paste0(target, " (binned)"), y = .x) +
theme_minimal() +
scale_x_discrete(labels = function(x) gsub(",", "\n", x))  # Wrapping long bin labels
)
walk(plots, print)
}
show.boxplot(data = df, cols = PREDICTORS, target = TARGET, bins = 10)
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
scale_x_log10(labels = scales::comma) +  # Log scale for skewed data
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
selected_df <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
write.csv(selected_df, file = "../../data/preprocessed/cars_v1.csv", row.names = FALSE)  # Avoid row numbers
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/preprocessed/cars_v1.csv", show_col_types = FALSE)
summary(df)
TARGET = 'Price'
# Create a new feature combining Brand + Model (e.g., "Toyota_Corolla")
EDA_selected = c('Brand_Model_encoded', 'Location_encoded', 'Car_Suv_encoded', 'Kilometres_num', 'Cylinders', 'ColourExtInt_encoded', 'FuelType_encoded','DriveType_encoded')
selected_data <- df %>% select(all_of(EDA_selected), all_of(TARGET))
selected_data <- selected_data %>% filter(complete.cases(.))
summary(selected_data)
# Function to winsorize
winsorize <- function(x, limits = c(0.01, 0.99)) {
x[x < quantile(x, limits[1], na.rm = TRUE)] <- quantile(x, limits[1], na.rm = TRUE)
x[x > quantile(x, limits[2], na.rm = TRUE)] <- quantile(x, limits[2], na.rm = TRUE)
x
}
# Apply to new features
selected_data <- selected_data %>%
mutate(across(
all_of(EDA_selected),  # Use all_of() for safety
winsorize
))
# Fixes the random number generator to ensure the same data split every time.
set.seed(123)  # For reproducibility
# Splits the data into 80% training and 20% testing, preserving the distribution of Price
train_index <- createDataPartition(selected_data$Price, p = 0.8, list = FALSE)
train_data <- selected_data[train_index, ]
test_data  <- selected_data[-train_index, ]
# Option A: Log-transform Price
# Applies the natural logarithm to Price in the training set only (to avoid data leakage).
train_data$log_Price <- log(train_data$Price)
# Option B: Remove extreme values (e.g., top/bottom 1%)
# price_cutoffs <- quantile(train_data$log_Price, c(0.01, 0.99))
# train_clean <- train_data %>%
#   filter(log_Price > price_cutoffs[1] & log_Price < price_cutoffs[2])
# install.packages("car")
# Check encoding direction
# cor(train_data$Brand_encoded, train_data$Price)  # Should be positive
car::vif(lm_model$finalModel)
# Train model
# Use formula syntax (Price ~ . uses all other columns as predictors)
# Create formula dynamically
# log_Price ~ Brand_Encoded + Model_encoded + ...
model_formula <- reformulate(EDA_selected, response = "log_Price")
# Train model
lm_model <- train(
model_formula,
data = train_data,
method = "lm",
trControl = trainControl(method = "cv", number = 5)
)
# Print model coefficients
summary(lm_model$finalModel)
# Predict on test data
test_data$log_Price_pred <- predict(lm_model, newdata = test_data)
# To revert to the unscaled values, we calculate the exponent of the logged values
test_data$Price_pred <- exp(test_data$log_Price_pred)
# --- 1. Plot: Predicted vs. Actual (log scale) ---
ggplot(test_data, aes(x = log(Price), y = log_Price_pred)) +
geom_point(alpha = 0.4, color = "blue") +
geom_abline(slope = 1, color = "red", linetype = "dashed") +
labs(title = "Predicted vs. Actual Prices (Log Scale)",
x = "Actual log(Price)", y = "Predicted log(Price)") +
theme_minimal()
# --- 2. Plot: Predicted vs. Actual (original price scale) ---
ggplot(test_data, aes(x = Price, y = Price_pred)) +
geom_point(alpha = 0.4, color = "darkgreen") +
geom_abline(slope = 1, color = "red", linetype = "dashed") +
labs(title = "Predicted vs. Actual Prices (Original Scale)",
x = "Actual Price", y = "Predicted Price") +
scale_x_continuous(labels = scales::dollar) +
scale_y_continuous(labels = scales::dollar) +
theme_minimal()
# residuals <- residuals(lm_model$finalModel)
# Extract residuals and fitted values
model_data <- data.frame(
Fitted = fitted(lm_model$finalModel),
Residuals = residuals(lm_model$finalModel)
)
# Converting to dataframe for ggplot
# residuals_df <- data.frame(Residuals = residuals)
# Creating histogram with density overlay with density curve
ggplot(model_data, aes(x = Residuals)) +
geom_histogram(
aes(y = after_stat(density)),
bins = 50,
fill = "steelblue",
color = "white",
alpha = 0.8
) +
geom_density(color = "red", linewidth = 1) +
labs(
title = "Distribution of Model Residuals",
x = "Residuals (Actual - Predicted Price)",
y = "Density"
) +
theme_minimal()
# Residuals vs. Fitted Plot
p1 <- ggplot(model_data, aes(x = Fitted, y = Residuals)) +
geom_point(alpha = 0.6, color = "steelblue") +
geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
geom_smooth(method = "loess", color = "darkgreen", se = FALSE) +
labs(
title = "Residuals vs. Fitted Values",
subtitle = "Check for homoscedasticity (constant variance)",
x = "Fitted Values (Predicted Price)",
y = "Residuals (Actual - Predicted)"
) +
theme_minimal()
p1
# QQ-Plot
p2 <- ggplot(model_data, aes(sample = Residuals)) +
stat_qq(color = "steelblue") +
stat_qq_line(color = "red", linetype = "dashed") +
labs(
title = "Normal Q-Q Plot",
subtitle = "Check for normality of residuals",
x = "Theoretical Quantiles",
y = "Sample Quantiles"
) +
theme_minimal()
p2
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
scale_x_log10(labels = scales::comma) +  # Log scale for skewed data
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
# A code chunk labeled setup.
# this chunk will not appear in the final document (no code, no output shown), but it will run
# Sets global options for all subsequent code chunks.
#echo = TRUE means R code will be displayed in the output (HTML/PDF).
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(conflicted)
library(corrplot)
library(purrr)
library(caret)
library(nnet)
library(pROC)
library(scales)  # for comma()
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
paste("Loading dataset from '", getwd(), "'")
df <- read_csv("../../data/raw/australian_vehicle_prices.csv", show_col_types = FALSE)
summary(df)
colnames(df)[colnames(df) == "Car/Suv"] <- "Car_Suv"
df$Brand_Model <- paste(df$Brand, df$Model)
PREDICTORS <- c('Brand_encoded', 'age', 'Model_encoded',
'Car_Suv_encoded', 'UsedOrNew_encoded',
'Transmission_encoded', 'Kilometres_num',
'Cylinders', 'Engine_L', 'DriveType_encoded',
'FuelType_encoded', 'FuelConsumption_num',
'ColourExtInt_encoded', 'Location_encoded',
'BodyType_encoded', 'Doors_num', 'Seats_num', 'Brand_Model_encoded')
TARGET <- 'Price'
df
# For a single column (e.g., 'Seats')
colMeans(is.na(df))
df <- df %>%
filter(complete.cases(.))
target.encode <- function(df, target, col) {
# Convert column name to symbol for tidy evaluation
col_sym <- sym(col)
encoded_col_name <- paste0(col, "_encoded")
# Step 1: Calculate mean target per group
avg_target <- df %>%
group_by(!!col_sym) %>%
summarise(mean_target = mean(.data[[target]], na.rm = TRUE), .groups = "drop") %>%
arrange(mean_target)
# Step 2: Assign ranks
avg_target <- avg_target %>%
mutate(!!encoded_col_name := as.numeric(factor(mean_target, levels = unique(mean_target))) - 1)
# Step 3: Join encoded column back to original dataframe
df <- df %>%
left_join(avg_target %>% select(!!col_sym, !!sym(encoded_col_name)), by = col)
return(df)
}
COLS_TO_ENCODE <- c('Brand', 'Model', 'Car_Suv', 'UsedOrNew', 'Transmission', 'DriveType', 'FuelType', 'ColourExtInt', 'Location', 'BodyType', 'Brand_Model')
df <- reduce(COLS_TO_ENCODE, ~ target.encode(df = .x, target = TARGET, col = .y), .init = df)
current_year <- as.numeric(format(Sys.Date(), "%Y"))
df$age <- current_year - df$Year
# extract actually replaces the original column with new ones based on regex match
df <- df %>%
extract(
Engine,                 # The source column containing engine info
into = c("Cylinders", "Engine_L"),  # New columns to create
regex = "(\\d+) cyl, (\\d+\\.?\\d*) L",  # Pattern to match
convert = TRUE          # Automatically convert to appropriate data types
)
df
df <- df %>%
mutate(
FuelConsumption_num = as.numeric(str_extract(FuelConsumption, "\\d+\\.?\\d*"))
)
df
df$Doors_num <- as.numeric(gsub("[^0-9]", "", df$Doors))
df$Seats_num <- as.numeric(gsub("[^0-9]", "", df$Seats))
df
unique(df$UsedOrNew)
summary(df)
df <- df %>%
mutate(Kilometres_num = as.numeric(gsub("[^0-9]", "", Kilometres)))
df <- df %>%
filter(!is.na(Kilometres_num), !is.na(Price))
show.correlation.plot <- function(df, target, col){
p <- ggplot(df, aes(x = .data[[col]], y = .data[[target]])) +
geom_point(alpha = 0.5, color = "steelblue") +
geom_smooth(method = "lm", color = "red") +  # Linear trend line
labs(title = paste0(target, " vs. ", col), x = col, y = target) +
theme_minimal()
return(p)
}
plots <- map(PREDICTORS, ~show.correlation.plot(df = df, target = TARGET, col = .x))
walk(plots, print)
show.corrplot <- function(matrix){
p <- corrplot(
matrix,
method = 'color',
type = 'lower',
tl.cex = 0.6,        # much smaller axis text
cl.cex = 0.6,        # smaller colorbar text
addCoef.col = "black",
number.cex = 0.5,    # smaller correlation coefficients
tl.srt = 45
)
print(p)
}
cor_data <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
cor_matrix <- cor(cor_data, use = "complete.obs")
show.corrplot(cor_matrix)
show.boxplot <- function(data, cols, target, bins = 5) {
data <- data %>%
mutate(target_binned = cut(.data[[target]], breaks = bins, include.lowest = TRUE))
plots <- map(cols, ~ggplot(
data,
aes(x = target_binned, y = .data[[.x]])) +
geom_boxplot(aes(group = target_binned)) +
labs(x = paste0(target, " (binned)"), y = .x) +
theme_minimal() +
scale_x_discrete(labels = function(x) gsub(",", "\n", x))  # Wrapping long bin labels
)
walk(plots, print)
}
show.boxplot(data = df, cols = PREDICTORS, target = TARGET, bins = 10)
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
# Histogram with log scale
ggplot(df, aes(x = Price)) +
geom_histogram(fill = "skyblue", color = "black", bins = 30) +
scale_x_log10(labels = scales::comma) +  # Log scale for skewed data
labs(
title = "Distribution of Vehicle Prices (Log Scale)",
x = "Price (Log10 Scale)",
y = "Count"
) +
theme_minimal()
selected_df <- df %>% select(all_of(PREDICTORS), all_of(TARGET))
write.csv(selected_df, file = "../../data/preprocessed/cars_v1.csv", row.names = FALSE)  # Avoid row numbers
getwd()
setwd("~/DataAnalysisProjects/OZNAL-project/shiny_app/app")
getwd()
renv::status()
install.packages("renv")  # if not already
renv::status()
library(renv)
install.packages(c("shiny", "tidyverse", "patchwork"))
renv::status()
renv::snapshot()
renv::status()
renv::restore()
renv::activate("C:/Users/fmojt/Documents/DataAnalysisProjects/OZNAL-project/shiny_app/app")
getwd()
renv::restore()
renv::restore()
renv::snapshot()
renv::status()
renv::snapshot()
getwd()
install.packages("renv")
library(renv)
renv::init()  # initializes the project and creates renv.lock
renv::status()
install.packages(c("shiny", "tidyverse", "patchwork"))
renv::snapshot()  # updates renv.lock with all used packages
renv::snapshot()  # updates renv.lock with all used packages
renv::activate("C:/Users/fmojt/Documents/DataAnalysisProjects/OZNAL-project/shiny_app/app")
renv::snapshot()
renv::snapshot()
getwd()
renv::activate("C:/Users/fmojt/Documents/DataAnalysisProjects/OZNAL-project/shiny_app/app")
renv::status()
renv::snapshot()
renv::deactivate()
renv::init()
renv::status()
renv::snapshot()
